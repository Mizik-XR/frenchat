
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY } from './config';
import { 
  APP_STATE, 
  detectLocalAIService,
  checkOfflineMode,
  preloadSession as compatPreloadSession
} from '@/compatibility/supabaseCompat';
import type { UserProfile, EdgeFunctionResponse } from './supabaseModels';

// Create client with error handling
let supabaseClient: any = null;

try {
  // Vérifier si on devrait utiliser le mode hors ligne
  checkOfflineMode();
  
  if (APP_STATE.isOfflineMode) {
    console.warn("Application en mode hors ligne, client Supabase non initialisé");
  } else {
    // Create client with optimized options
    supabaseClient = createClient<Database>(
      SUPABASE_URL, 
      SUPABASE_PUBLISHABLE_KEY,
      {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
          detectSessionInUrl: true,
          storageKey: 'supabase.auth.token'
        },
        realtime: {
          params: {
            eventsPerSecond: 10
          },
          timeout: 30000, // 30 secondes
          reconnectAfterMs: (attempt) => Math.min(attempt * 2000, 60000),
          maxRetries: 5 // Réduire pour éviter le spam
        },
        global: {
          fetch: (...args) => {
            // Handle fetch arguments properly
            const request = args[0];
            const options = args[1] || {};
            
            // Conditional cache options
            const updatedOptions = {
              ...options,
              cache: request.toString().includes('auth/') ? 'no-cache' : 'default'
            };
            
            return fetch(request, updatedOptions);
          }
        }
      }
    );
    console.log("Client Supabase initialized successfully with improved WebSocket configuration");
  }
} catch (error) {
  console.error("CRITICAL ERROR: Failed to initialize Supabase client:", error);
  if (error instanceof Error) {
    APP_STATE.logSupabaseError(error);
  }
  supabaseClient = null;
  APP_STATE.setOfflineMode(true);
}

// Export Supabase client and utilities
export const supabase = supabaseClient;

// Réexportation des constantes d'APP_STATE pour maintenir la compatibilité API
export { APP_STATE, checkOfflineMode, detectLocalAIService };

// Utilisation de la fonction de compatibilité
export const preloadSession = compatPreloadSession;

// Réexporte le type EdgeFunctionResponse pour qu'il soit disponible aux imports
export type { EdgeFunctionResponse };

// Déplacer les fonctions de profileUtils pour éviter la dépendance circulaire
export async function handleProfileQuery(userId: string): Promise<ProfileQueryResult> {
  // Si on est en mode hors ligne, fournir un profil par défaut
  if (APP_STATE.isOfflineMode || !supabase) {
    console.log("Mode hors ligne actif, utilisation d'un profil par défaut");
    return { 
      data: { 
        id: userId,
        is_first_login: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      } as UserProfile, 
      error: null 
    };
  }
  
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();
      
    if (error) {
      if (error.message?.includes('infinite recursion')) {
        console.warn("Database policy recursion detected. Using fallback profile.");
        
        // Si nous détectons une récursion infinie, créons un profil minimal
        try {
          // Tenter de créer le profil manuellement
          const { error: insertError } = await supabase
            .from('profiles')
            .insert({ 
              id: userId,
              is_first_login: true,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .single();
            
          if (insertError) {
            console.error("Erreur lors de la création du profil de secours:", insertError);
          } else {
            console.log("Profil de secours créé avec succès");
            
            // Récupérer le nouveau profil
            const { data: newProfile, error: newError } = await supabase
              .from('profiles')
              .select('*')
              .eq('id', userId)
              .single();
              
            if (!newError) {
              return { data: newProfile, error: null };
            }
          }
        } catch (createError) {
          console.error("Erreur lors de la tentative de création de profil:", createError);
        }
        
        // Return a minimal fallback profile if all else fails
        return { 
          data: { 
            id: userId,
            is_first_login: true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          } as UserProfile, 
          error: null 
        };
      }
      return { data: null, error };
    }
    
    return { data, error: null };
  } catch (err) {
    console.error("Error querying profile:", err);
    
    // En cas d'erreur, fournir un profil de secours
    return { 
      data: { 
        id: userId,
        is_first_login: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      } as UserProfile, 
      error: { message: err instanceof Error ? err.message : 'Unknown error' } 
    };
  }
}

// Définir le type ProfileQueryResult directement dans ce fichier
interface ProfileQueryResult {
  data: UserProfile | null;
  error: { message: string } | null;
}

// Fonction simplifiée pour vérifier la connexion à Supabase (déplacée de profileUtils)
export async function checkSupabaseConnection(): Promise<boolean> {
  if (APP_STATE.isOfflineMode) return false;
  
  try {
    const { error } = await supabase.from('profiles').select('count').limit(1);
    return !error;
  } catch (err) {
    console.error("Erreur de connexion à Supabase:", err);
    return false;
  }
}
