
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { getBaseUrl } from '@/utils/environment';

// Prioritize environment variables if defined
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://dbdueopvtlanxgumenpu.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRiZHVlb3B2dGxhbnhndW1lbnB1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzk5NzQ0NTIsImV4cCI6MjA1NTU1MDQ1Mn0.lPPbNJANU8Zc7i5OB9_atgDZ84Yp5SBjXCiIqjA79Tk";

// Export SITE_URL for OAuth redirects
export const SITE_URL = getBaseUrl();

// Global app state for handling offline mode
export const APP_STATE = {
  isOfflineMode: false,
  hasSupabaseError: false,
  lastSupabaseError: null as Error | null,
  setOfflineMode(value: boolean) {
    this.isOfflineMode = value;
    localStorage.setItem('OFFLINE_MODE', value ? 'true' : 'false');
    console.log(`Application ${value ? 'entered' : 'exited'} offline mode`);
  },
  logSupabaseError(error: Error) {
    this.hasSupabaseError = true;
    this.lastSupabaseError = error;
    console.error('Supabase error:', error);
  }
};

// Préchargement de la session Supabase
export const preloadSession = async () => {
  if (APP_STATE.isOfflineMode) {
    console.log("Application en mode hors ligne, préchargement de session ignoré.");
    return { session: null };
  }
  
  try {
    console.log("Tentative de préchargement de la session Supabase...");
    console.log("URL Supabase:", SUPABASE_URL);
    console.log("Clé Supabase définie:", !!SUPABASE_PUBLISHABLE_KEY);
    
    if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
      const error = new Error("Configuration Supabase incomplète");
      APP_STATE.logSupabaseError(error);
      throw error;
    }
    
    // Vérifier d'abord si le client est défini
    if (!supabase) {
      const error = new Error("Client Supabase non initialisé");
      APP_STATE.logSupabaseError(error);
      throw error;
    }
    
    const { data, error } = await supabase.auth.getSession();
    
    if (error) {
      APP_STATE.logSupabaseError(error);
      throw error;
    }
    
    console.log("Session Supabase préchargée avec succès:", data.session ? "Session active" : "Pas de session");
    return data;
  } catch (error) {
    console.error("Erreur de préchargement de session Supabase:", error);
    if (error instanceof Error) {
      APP_STATE.logSupabaseError(error);
    }
    
    // Activer le mode hors ligne si nous rencontrons des erreurs de connexion
    if (error instanceof Error && (
      error.message.includes('Failed to fetch') || 
      error.message.includes('NetworkError') || 
      error.message.includes('Network request failed')
    )) {
      APP_STATE.setOfflineMode(true);
    }
    
    throw error;
  }
};

// Détection dynamique du service d'IA locale
export const detectLocalAIService = async () => {
  try {
    // Si déjà en mode hors ligne, ignore la détection
    if (APP_STATE.isOfflineMode) {
      console.log("Mode hors ligne activé, utilisation du service cloud par défaut");
      localStorage.setItem('aiServiceType', 'cloud');
      return { available: false, url: null };
    }
    
    // Teste d'abord Ollama, qui est prioritaire
    try {
      const ollamaAvailable = await fetch('http://localhost:11434/api/version', {
        signal: AbortSignal.timeout(1500)
      });
      
      if (ollamaAvailable.ok) {
        console.log("Service Ollama détecté à http://localhost:11434");
        localStorage.setItem('aiServiceType', 'local');
        localStorage.setItem('localAIUrl', 'http://localhost:11434');
        localStorage.setItem('localProvider', 'ollama');
        return { available: true, url: 'http://localhost:11434', provider: 'ollama' };
      }
    } catch (e) {
      console.log("Ollama non détecté:", e instanceof Error ? e.message : String(e));
    }
    
    // Teste ensuite le serveur Python local
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000); // Timeout après 2 secondes
    
    const localBaseUrls = [
      'http://localhost:8000',
      'http://127.0.0.1:8000',
      // Ajoutez d'autres ports potentiels si nécessaire
    ];
    
    let localAIAvailable = false;
    let localAIUrl = '';
    
    for (const url of localBaseUrls) {
      try {
        console.log(`Tentative de connexion à ${url}/health...`);
        const response = await fetch(`${url}/health`, {
          method: 'GET',
          signal: controller.signal
        });
        
        if (response.ok) {
          localAIAvailable = true;
          localAIUrl = url;
          console.log(`Service d'IA local détecté: ${url}`);
          break;
        }
      } catch (e) {
        console.log(`Échec de connexion à ${url}: ${e instanceof Error ? e.message : String(e)}`);
        // Ignore les erreurs et continue avec l'URL suivante
        continue;
      }
    }
    
    clearTimeout(timeoutId);
    
    if (localAIAvailable) {
      console.log("Service d'IA Python local détecté:", localAIUrl);
      localStorage.setItem('aiServiceType', 'local');
      localStorage.setItem('localAIUrl', localAIUrl);
      localStorage.setItem('localProvider', 'python');
      return { available: true, url: localAIUrl, provider: 'python' };
    } else {
      console.log("Aucun service d'IA local détecté, utilisation du service cloud");
      localStorage.setItem('aiServiceType', 'cloud');
      localStorage.removeItem('localAIUrl');
      return { available: false, url: null };
    }
  } catch (error) {
    console.error("Erreur lors de la détection du service d'IA local:", error);
    localStorage.setItem('aiServiceType', 'cloud');
    return { available: false, url: null };
  }
};

// Vérifier si l'application est en mode hors ligne
export const checkOfflineMode = () => {
  const savedMode = localStorage.getItem('OFFLINE_MODE');
  if (savedMode === 'true') {
    APP_STATE.setOfflineMode(true);
    return true;
  }
  return false;
};

// Tester la validation des paramètres Supabase
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error("ERREUR CRITIQUE: Configuration Supabase manquante!");
  if (typeof window !== 'undefined') {
    // Afficher une alerte dans la console du navigateur
    console.error(
      "%c⚠️ ERREUR DE CONFIGURATION SUPABASE ⚠️",
      "background: #f44336; color: white; font-size: 16px; padding: 8px;"
    );
    console.error(
      "%cURL Supabase ou clé d'API manquante. Vérifiez votre configuration.",
      "font-size: 14px;"
    );
  }
}

// Create client with error handling
let supabaseClient: any = null;
try {
  // Vérifier si on devrait utiliser le mode hors ligne
  checkOfflineMode();
  
  if (APP_STATE.isOfflineMode) {
    console.warn("Application en mode hors ligne, client Supabase non initialisé");
  } else {
    // Create client with optimized options
    supabaseClient = createClient<Database>(
      SUPABASE_URL, 
      SUPABASE_PUBLISHABLE_KEY,
      {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
          detectSessionInUrl: true,
          storageKey: 'supabase.auth.token'
        },
        global: {
          fetch: (...args) => {
            // Handle fetch arguments properly
            const request = args[0];
            const options = args[1] || {};
            
            // Conditional cache options
            const updatedOptions = {
              ...options,
              cache: request.toString().includes('auth/') ? 'no-cache' : 'default'
            };
            
            return fetch(request, updatedOptions);
          }
        }
      }
    );
    console.log("Client Supabase initialized successfully");
  }
} catch (error) {
  console.error("CRITICAL ERROR: Failed to initialize Supabase client:", error);
  if (error instanceof Error) {
    APP_STATE.logSupabaseError(error);
  }
  supabaseClient = null;
  APP_STATE.setOfflineMode(true);
}

// Export Supabase client
export const supabase = supabaseClient;

// Type helper for Edge Function responses
export type EdgeFunctionResponse<T> = {
  data: T;
  error: null;
} | {
  data: null;
  error: {
    message: string;
  };
};

// Add fallback functions to handle database errors gracefully
export const handleProfileQuery = async (userId: string) => {
  // Si on est en mode hors ligne, fournir un profil par défaut
  if (APP_STATE.isOfflineMode || !supabase) {
    console.log("Mode hors ligne actif, utilisation d'un profil par défaut");
    return { 
      data: { 
        id: userId,
        is_first_login: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }, 
      error: null 
    };
  }
  
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();
      
    if (error) {
      if (error.message?.includes('infinite recursion')) {
        console.warn("Database policy recursion detected. Using fallback profile.");
        
        // Si nous détectons une récursion infinie, créons un profil minimal
        try {
          // Tenter de créer le profil manuellement
          const { error: insertError } = await supabase
            .from('profiles')
            .insert({ 
              id: userId,
              is_first_login: true,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .single();
            
          if (insertError) {
            console.error("Erreur lors de la création du profil de secours:", insertError);
          } else {
            console.log("Profil de secours créé avec succès");
            
            // Récupérer le nouveau profil
            const { data: newProfile, error: newError } = await supabase
              .from('profiles')
              .select('*')
              .eq('id', userId)
              .single();
              
            if (!newError) {
              return { data: newProfile, error: null };
            }
          }
        } catch (createError) {
          console.error("Erreur lors de la tentative de création de profil:", createError);
        }
        
        // Return a minimal fallback profile if all else fails
        return { 
          data: { 
            id: userId,
            is_first_login: true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          }, 
          error: null 
        };
      }
      return { data: null, error };
    }
    
    return { data, error: null };
  } catch (err) {
    console.error("Error querying profile:", err);
    
    // En cas d'erreur, fournir un profil de secours
    return { 
      data: { 
        id: userId,
        is_first_login: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }, 
      error: { message: err instanceof Error ? err.message : 'Unknown error' } 
    };
  }
};

// Fonction simplifiée pour vérifier la connexion à Supabase
export const checkSupabaseConnection = async (): Promise<boolean> => {
  if (APP_STATE.isOfflineMode) return false;
  
  try {
    const { error } = await supabase.from('profiles').select('count').limit(1);
    return !error;
  } catch (err) {
    console.error("Erreur de connexion à Supabase:", err);
    return false;
  }
};

// Preload session if we're in a browser
if (typeof window !== 'undefined') {
  // Non-blocking preload
  setTimeout(() => {
    preloadSession().catch(err => {
      console.warn("Session preload failed:", err);
    });
  }, 0);
  
  // Local AI service detection
  setTimeout(() => {
    detectLocalAIService().catch(err => {
      console.warn("Local AI service detection failed:", err);
    });
  }, 1000);
}

// Ce fichier est long, mais il est important que toutes ces fonctions soient regroupées ici pour la cohérence
// TODO: Considérer de refactoriser ce fichier en modules plus petits lorsque le temps le permettra
